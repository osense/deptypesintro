\documentclass[12pt]{article}
\usepackage[mathletters]{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{proof}
\usepackage{amsmath}
\usepackage{latexsym}


\title{Correspondece between Second-order logic and~Polymorphic lambda calculus}
\author{Adam Krupicka\\
        Faculty of Informatics\\
        Masaryk University, Brno
}
\date{23.5.2016}


\begin{document}
\maketitle

\begin{abstract}
ABSTRACT
\end{abstract}


\section{Introduction}
Into…


\section{Definitions}
\textbf{Type} can generally be understood as a set of objects that inhabit it (e.g.\ the type ℕ of all natural numbers, including zero).

To say that some variable is \textbf{free} in an object (e.g.\ a type or a formula) means that it does not occur anywhere in the given object (e.g.\ $A$ is free in $B$ or $B → B$, but not in $A → B → B$).

\textbf{$\mathcal{L} (\mathcal{M})$} denotes the language of some calculus \mathcal{M}, that is, all the terms that can be constructed from some fixed starting set of variables.

\section{Simply typed lambda calculus}
In this section we will remind the reader of the well-known correspondence between Natural deduction and the Simply typed λ calculus. We won't go into much detail, as this is covered well in other literature (e.g.~\cite{??}).

\subsection{Natural deduction}
Natural deduction is a proof calculus which can be used in both Classical and Intuitionistic logic. Consider a fragment of Natural deduction under the latter interpretation, consisting only of conjunction and implication.
\paragraph{Hypothesis}
\[A\]
\paragraph{Introduction rules}
$$
\infer[\mathrm{∧I}]{A ∧ B}{A & B}
\qquad
\infer[\mathrm{⇒I}]{A ⇒ B}{\infer*{B}{[A]}}
$$
\paragraph{Elimination rules}
$$
\infer[\mathrm{∧₁E}]{A}{A ∧ B}
\qquad
\infer[\mathrm{∧₂E}]{B}{A ∧ B}
\qquad
\infer[\mathrm{⇒E}]{B}{A & A ⇒ B}
$$

\subsection{Simply typed λ calculus}
\label{simply}
We can immediately observe the correspondence between types and proofs:
\begin{itemize}
    \item A variable $x$ is a term of some atomic type T, \hfill (hypothesis)
    \item If $u$ and $v$ are terms of type $U$ and $V$ respectively, then $⟨u,v⟩$ is a term of type $U × V$, \hfill ($\mathrm{∧I}$)
    \item If $t$ is a term of type $U × V$, then $π₁ \ t$ is a term of type $U$, \hfill ($\mathrm{∧₁E}$)
    \item If $t$ is a term of type $U × V$, then $π₂ \ t$ is a term of type $V$, \hfill ($\mathrm{∧₁E}$)
    \item If $t$ is a term of type $T$, then $λx:U.t$ is a term of type $U → V$, \hfill ($\mathrm{⇒I}$)
    \item If $u$ and $v$ are terms of type $V → T$ and $v$ respectively, then $u \ v$ is a term of type $T$. \hfill ($\mathrm{⇒E}$)
\end{itemize}

\subsection{Evaluation}
Evaluation can be understood as simple rewriting of terms, according to these equations:
\[(λx:U.t) \ u → t[x:=u] \qquad π₁ \ ⟨u,v⟩ → u \qquad π₂ \ ⟨u,v⟩ → v\]
The first rule is known as β-reduction. From the logical point of view, these rules correspond to the normalization of proofs.

\subsection{Pairs in the Simply typed λ calculus}
\label{crappairs}
It should be noted that, from the calculus's point of view, it isn't necessary to explicitly define pairs as we have done above. Pairs can be easily defined from within the calculus:
\begin{align*}
    \mathrm{pair} &≡ λa:ℕλb:ℕλx:(ℕ → ℕ → ℕ).x \ a \ b\\
    \mathrm{fst} \ t &≡ t \ (λx:ℕλy:ℕ.x)\\
    \mathrm{snd} \ t &≡ t \ (λx:ℕλy:ℕ.y)
\end{align*}
However, such a construct would only work for pairs of a single type (here the atomic type of natural numbers, ℕ).


\section{Polymorphic λ calculus}
In the previous section, we have described the basic correspondence between proofs and types. To this effect, we have utilized only a few logical operators. One might naturally be curious about what happens when we attempt to introduce back some of the unconsidered operators. We will start with the ∀ quantifier, as this is perhaps the easiest one.

\subsection{∀ fragment of Second-order propositional logic}
Now let us go further than this — we will allow quantifying not only over variables, but also over sets. Sets in our case simply mean types (recall that type was generally understood as a set of objects).
\paragraph{Introduction and elimination rules}
$$
\infer[\mathrm{∀I}]{∀X.A}{A}
\qquad
\infer[\mathrm{∀E}]{A[X:=t]}{∀X.A}
$$
In the case of the $\mathrm{∀I}$ rule it is necessary to ensure that the variable $X$ occurs unbounded in $A$.

\subsection{Back to the calculus}
Intuitivelly, the first rule from the previous section says that once we have a valid term $t:T$ (e.g. $λx:ℕ.x$ of type $ℕ → ℕ$), we can generalize over some atomic type present in $T$ (in our example, the only option is to generalize over $ℕ$, obtaining $Λαλx:α.x$ of type $∀α.α → α$, the polymorphic identity function). The second rule comes into play during evaluation: it allows us to instantiate the function back into some specific type. Typically, greek lower case letters are used to denote types over which we have abstracted.

We can therefore extend the definition of λ→ thusly:
\begin{itemize}
    \item If $t$ is a term of type $T$ and X is not free in $T$, then $Λαt$ is a term of type $∀α.T$ (universal abstraction),
    \item If $u$ is a term of type $∀α.U$ and $V$ is some type, then $u \ V$ is a term of type $U[α:=V]$ (universal application).
\end{itemize}
This system is also known as Girard's System F. We will use the notation λ2 to refer to it. Note that $\mathcal{L}(λ→) ⊂ \mathcal{L}(λ2)$.
\paragraph{Evaluation}
While we will soon see that we can drop all the rules for pairs, we need a new rule for universal application:
\[(∀α.T) \ U → T[α:=U]\]
\paragraph{Example}
We can use this to generalize our example with pairs from~\ref{crappairs}, allowing us to abandon the explicit rules for pairs from λ→ completely:
\begin{align*}
    \mathrm{pair} &≡ λx:αλy:βΛγλz:(α → β → γ).x \ a \ b\\
    \mathrm{fst} \ t &≡ t \ α \ (λx:αλy:β.x)\\
    \mathrm{snd} \ t &≡ t \ β \ (λx:αλy:β.y)
\end{align*}
Let us evaluate an example term:
\begin{align*}
    \mathrm{fst} \ (\mathrm{pair} \ p₁ \ p₂) =& \ \mathrm{fst} \ (λa:αλb:βΛγλx:(α → β → γ).x \ a \ b) \ p₁ \ p₂\\
    \leadsto& \ \mathrm{fst} \ (Λγλx:(α → β → γ).x \ p₁ \ p₂)\\
    =& \ (Λγλx:(α → β → γ).x \ p₁ \ p₂) \ α \ (λx:αλy:β.x)\\
    \leadsto& \ (λx:(α → β → α).x \ p₁ \ p₂) \ (λx:αλy:β.x)\\
    \leadsto& \ (λx:αλy:β.x) \ p₁ \ p₂\\
    \leadsto& \ p₁\\
\end{align*}
\end{document}

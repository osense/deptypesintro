\documentclass[12pt]{article}
\usepackage[mathletters]{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{proof}
\usepackage{amsmath}
\usepackage{latexsym}


\title{Correspondece between Second-order logic and~Polymorphic lambda calculus}
\author{Adam Krupicka\\
        Faculty of Informatics\\
        Masaryk University, Brno
}
\date{23.5.2016}


\begin{document}
\maketitle

\begin{abstract}
ABSTRACT
\end{abstract}


\section{Introduction}
Into…


\section{Simply typed lambda calculus}
In this section we will remind the reader of the well-known correspondence between Natural deduction and the Simply typed λ calculus. We won't go into much detail, as this is covered well in other literature (e.g.~\cite{??}).

\subsection{Natural deduction}
Natural deduction is a proof calculus which can be used in both Classical and Intuitionistic logic. Consider a fragment of Natural deduction under the latter interpretation, consisting only of conjunction and implication.
\paragraph{Hypothesis}
\[A\]
\paragraph{Introduction rules}
$$
\infer[\mathrm{∧I}]{A ∧ B}{A & B}
\qquad
\infer[\mathrm{⇒I}]{A → B}{\infer*{B}{[A]}}
$$
\paragraph{Elimination rules}
$$
\infer[\mathrm{∧₁E}]{A}{A ∧ B}
\qquad
\infer[\mathrm{∧₂E}]{B}{A ∧ B}
\qquad
\infer[\mathrm{⇒E}]{B}{A & A → B}
$$

\subsection{Simply typed λ calculus}
\label{simply}
We can immediately observe the correspondence between types and proofs:
\begin{itemize}
    \item A variable $x:T$ is a term of the atomic type T, \hfill (hypothesis)
    \item If $u:U$ and $v:V$ are terms, then $⟨u,v⟩:(U × V)$ is a term, \hfill ($\mathrm{∧I}$)
    \item If $t:(U × V)$ is a term, then $(π₁ \ t):U$ is a term, \hfill ($\mathrm{∧₁E}$)
    \item If $t:(U × V)$ is a term, then $(π₂ \ t):V$ is a term, \hfill ($\mathrm{∧₂E}$)
    \item If $t:T$ is a term, then $λx:U.t$ is a term of type U → V, \hfill ($\mathrm{⇒I}$)
    \item If $u:(V → T)$ and $v:V$ are terms, then $(u \ v):T$ is a term. \hfill ($\mathrm{⇒E}$)
\end{itemize}

\subsection{Evaluation}
Evaluation can be understood as simple rewriting of terms, according to these equations:
\[(λx:U.t) \ u → t[x:=u] \qquad π₁ \ ⟨u,v⟩ → u \qquad π₂ \ ⟨u,v⟩ → v\]
The first rule is known as β-reduction. From the logical point of view, this corresponds to normalization of proofs.

\subsection{Pairs in the Simply typed λ calculus}
\label{crappairs}
It should be noted that, from the calculus's point of view, it isn't necessary to explicitly define pairs as we have done above. Pairs can be easily defined from within the calculus:
\begin{align*}
    \mathrm{pair} &≡ λa:ℕλb:ℕλx:(ℕ → ℕ → ℕ).x \ a \ b\\
    \mathrm{fst} \ t &≡ t \ (λx:ℕλy:ℕ.x)\\
    \mathrm{snd} \ t &≡ t \ (λx:ℕλy:ℕ.y)
\end{align*}
However, such a construct would only work for pairs of a single type (here the atomic type of natural numbers, ℕ). In addition, the correspondence between the rules associated with ∧ and pairs is clearer in this way.


\section{Polymorphic λ calculus}
In the previous section, we have described the basic correspondence between proofs and types. To this effect, we have utilized only a few logical operators. One might naturally be curious about what happens when we attempt to introduce back some of the unconsidered operators. We will start with the ∀ quantifier, as this is perhaps the easiest one.

\subsection{∀ fragment of Second-order propositional logic}
Now let us go further than this — we will allow quantifying not only over variables, but also over sets. Sets in our case simply mean types (recall that type was generally understood as a set of objects).
\paragraph{Introduction and elimination rules}
$$
\infer[\mathrm{∀I}]{∀X.A}{A}
\qquad
\infer[\mathrm{∀E}]{A[X:=t]}{∀X.A}
$$
In the case of the $\mathrm{∀I}$ rule it is necessary to ensure that the variable $X$ occurs unbounded in $A$.

\subsection{Back to the calculus}
Intuitivelly, the first rule from the previous section says that once we have a valid term $t:T$ (e.g. $λx:ℕ.x$ of type $ℕ → ℕ$), we can generalize over some atomic type present in $T$ (in our example, the only option is to generalize over $ℕ$, obtaining $Λαλx:α.x$ of type $∀α.α → α$, the polymorphic identity function). The second rule comes into play during evaluation: it allows us to instantiate the function back into some specific type. Typically, greek lower case letters are used to denote abstracted types.
\paragraph{}
We can therefore extend the definition of λ→ thusly:
\begin{itemize}
    \item If $t:T$ is a term and X is not free in T, then $Λαt:(∀α.T)$ is a term (universal abstraction),
    \item If $u:(∀α.U)$ is a term and $V$ is a type, then $(u \ V):U[α:=V]$ is a term (universal application).
\end{itemize}
This system is also known as Girard's System F. We will use the notation λ2 to refer to it. Note that $\mathcal{L}(λ→) ⊂ \mathcal{L}(λ2)$.
\paragraph{Evaluation}
While we will soon see that we can drop all the rules for pairs, we need a new rule for universal application:
\[(∀α.T) \ U → T[α:=U]\]
\paragraph{Example}
We can use this to generalize our example with pairs from~\ref{crappairs}, allowing us to abandon the explicit rules for pairs from λ→ completely:
\begin{align*}
    \mathrm{pair} &≡ λx:αλy:βΛγλz:(α → β → γ).x \ a \ b\\
    \mathrm{fst} \ t &≡ t \ α \ (λx:αλy:β.x)\\
    \mathrm{snd} \ t &≡ t \ β \ (λx:αλy:β.y)
\end{align*}
Let us evaluate an example term:
\begin{align*}
    \mathrm{fst} \ (\mathrm{pair} \ p₁ \ p₂) =& \ \mathrm{fst} \ (λa:αλb:βΛγλx:(α → β → γ).x \ a \ b) \ p₁ \ p₂\\
    \leadsto& \ \mathrm{fst} \ (Λγλx:(α → β → γ).x \ p₁ \ p₂)\\
    =& \ (Λγλx:(α → β → γ).x \ p₁ \ p₂) \ α \ (λx:αλy:β.x)\\
    \leadsto& \ (λx:(α → β → α).x \ p₁ \ p₂) \ (λx:αλy:β.x)\\
    \leadsto& \ (λx:αλy:β.x) \ p₁ \ p₂\\
    \leadsto& \ p₁\\
\end{align*}
\end{document}

\documentclass[12pt]{article}
\usepackage[mathletters]{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english]{babel}
\usepackage{proof}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{latexsym}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}

\title{Correspondece between Second-order logic and~Polymorphic lambda calculus}
\author{Adam Krupicka\\
        Faculty of Informatics\\
        Masaryk University, Brno
}
\date{23.5.2016}


\begin{document}
\maketitle

\begin{abstract}
ABSTRACT
\end{abstract}


\section{Introduction}
Into…


\section{Definitions}

To say that some variable is \textbf{free} in a type means that it does not occur anywhere in it (e.g.\ $A$ is free in $B$ or $B → B$, but not in $A → B → B$).

\textbf{$\mathcal{L} (\mathcal{M})$} denotes the language of some calculus \mathcal{M}, that is, all the terms that can be constructed from some fixed starting set of variables.

\section{Simply typed lambda calculus}
In this section we will remind the reader of the well-known correspondence between Natural deduction and the Simply typed λ calculus. We won't go into much detail, as this is covered well in other literature (e.g.~\cite{??}).

\subsection{Natural deduction}
Natural deduction is a proof calculus which can be used in both Classical and Intuitionistic logic. Consider a fragment of Natural deduction under the latter interpretation, consisting only of conjunction and implication.
\paragraph{Hypothesis}
\[A\]
\paragraph{Introduction rules}
$$
\infer[\mathrm{∧I}]{A ∧ B}{A & B}
\qquad
\infer[\mathrm{⇒I}]{A ⇒ B}{\infer*{B}{[A]}}
$$
\paragraph{Elimination rules}
$$
\infer[\mathrm{∧₁E}]{A}{A ∧ B}
\qquad
\infer[\mathrm{∧₂E}]{B}{A ∧ B}
\qquad
\infer[\mathrm{⇒E}]{B}{A & A ⇒ B}
$$

\subsection{Simply typed λ calculus}
\label{simply}
\begin{definition}
    Type is a set of objects that are said to inhabit it, e.g.\ the type $ℕ$ of all natural numbers, including zero.
\end{definition}
We can immediately observe the correspondence between types and proofs:
\begin{itemize}
    \item A variable $x$ is a term of some atomic type T, \hfill (hypothesis)
    \item If $u$ and $v$ are terms of type $U$ and $V$ respectively, then $⟨u,v⟩$ is a term of type $U × V$, \hfill ($\mathrm{∧I}$)
    \item If $t$ is a term of type $U × V$, then $π₁ \ t$ is a term of type $U$, \hfill ($\mathrm{∧₁E}$)
    \item If $t$ is a term of type $U × V$, then $π₂ \ t$ is a term of type $V$, \hfill ($\mathrm{∧₁E}$)
    \item If $t$ is a term of type $T$, then $λx:U.t$ is a term of type $U → V$, \hfill ($\mathrm{⇒I}$)
    \item If $u$ and $v$ are terms of type $U$ and $U → V$ respectively, then $u \ v$ is a term of type $V$. \hfill ($\mathrm{⇒E}$)
\end{itemize}

\subsection{Evaluation}
Evaluation can be understood as simple rewriting of terms, according to these equations:
\[(λx:U.t) \ u → t[x:=u] \qquad π₁ \ ⟨u,v⟩ → u \qquad π₂ \ ⟨u,v⟩ → v\]
The first rule is known as β-reduction. From the logical point of view, these rules correspond to the normalization of proofs.

\subsection{Pairs in the Simply typed λ calculus}
\label{crappairs}
It should be noted that, from the calculus's point of view, it isn't necessary to explicitly define pairs as we have done above. Pairs can be easily defined from within the calculus:
\begin{align*}
    \mathrm{pair} &≡ λa:ℕλb:ℕλx:(ℕ → ℕ → ℕ).x \ a \ b\\
    \mathrm{fst} \ t &≡ t \ (λx:ℕλy:ℕ.x)\\
    \mathrm{snd} \ t &≡ t \ (λx:ℕλy:ℕ.y)
\end{align*}
However, such a construct would only work for pairs of a single type (here the atomic type of natural numbers, ℕ).


\section{Universal quantification}
In the previous section, we have described the basic correspondence between proofs and types. To this effect, we have utilized only a few logical operators. One might naturally be curious about what happens when we attempt to introduce back some of the unconsidered operators. We will start with the ∀ quantifier, as this is perhaps the easiest one.

\subsection{Second-order propositional logic}
Quantifying on the order of variables would require us to introduce some concept of variables into our Natural deduction calculus; it seems that it would take us in some more complex direction. Instead, we can allow quantification over propositions. This seems more natural, as we have already observed that propositions correspond to types. The new rules for Natural deduction therefore are:
\paragraph{Introduction and elimination rules}
$$
\infer[\mathrm{∀I}]{∀X.A}{A}
\qquad
\infer[\mathrm{∀E}]{A[X:=t]}{∀X.A}
$$
In the case of the $\mathrm{∀I}$ rule it is necessary to ensure that the variable $X$ occurs unbounded in $A$.

\subsection{Polymorphic λ calculus}
Intuitively, the first rule from the previous section can be seen as saying that once we have a valid term $t:T$ (e.g. $λx:ℕ.x$ of type $ℕ → ℕ$), we can generalize over some atomic type present in $T$ (in our example, the only option is to generalize over $ℕ$, obtaining $Λαλx:α.x$ of type $∀α.α → α$, the polymorphic identity function). The second rule comes into play during evaluation: it allows us to instantiate the function back into some specific type. Typically, Greek lower case letters are used to denote types over which we have abstracted.

We can therefore extend the definition of λ→ thusly:
\begin{itemize}
    \item If $t$ is a term of type $T$ and α is not free in $T$, then $Λα.t$ is a term of type $∀α.T$ (universal abstraction),
    \item If $u$ is a term of type $∀α.U$ and $V$ is some type, then $u \ V$ is a term of type $U[α:=V]$ (universal application).
\end{itemize}
This system is also known as Girard's System F. We will use the notation λ2 to refer to it.
\paragraph{Evaluation}
While we will soon see that we can drop all the rules for pairs, we need a new rule for universal application:
\[(∀α.T) \ U → T[α:=U]\]

\subsection{Pairs in λ2}
\label{pairs}
We can use this to generalize our example with pairs from~\ref{crappairs}, allowing us to abandon the explicit rules for pairs from λ→ completely:
\begin{align*}
    \mathrm{pair} &≡ λx:αλy:βΛγλz:(α → β → γ).x \ a \ b\\
    \mathrm{fst} \ t &≡ t \ α \ (λx:αλy:β.x)\\
    \mathrm{snd} \ t &≡ t \ β \ (λx:αλy:β.y)
\end{align*}
Let us evaluate an example term:
\begin{align*}
    \mathrm{fst} \ (\mathrm{pair} \ p₁ \ p₂) =& \ \mathrm{fst} \ (λa:αλb:βΛγλx:(α → β → γ).x \ a \ b) \ p₁ \ p₂\\
    \leadsto& \ \mathrm{fst} \ (Λγλx:(α → β → γ).x \ p₁ \ p₂)\\
    =& \ (Λγλx:(α → β → γ).x \ p₁ \ p₂) \ α \ (λx:αλy:β.x)\\
    \leadsto& \ (λx:(α → β → α).x \ p₁ \ p₂) \ (λx:αλy:β.x)\\
    \leadsto& \ (λx:αλy:β.x) \ p₁ \ p₂\\
    \leadsto& \ p₁\\
\end{align*}

\begin{theorem}
    $\mathcal{L}(λ→) ⊂ \mathcal{L}(λ2)$
\end{theorem}
\noindent\textit{Proof.}
\begin{itemize}
    \item $\mathcal{L}(λ→) ⊆ \mathcal{L}(λ2)$: With the exception of pairs, we have retained all rules already present in λ→. We have showed how to create pairs inside λ2 in~\ref{pairs}
    \item $\mathcal{L}(λ→) ≠ \mathcal{L}(λ2)$: $Λα.t ∈ \mathcal{L}(λ2)$, however $Λα.t ∉ \mathcal{L}(λ→)$ for any term $t$ of type $T$ where α is not free on $T$.
\end{itemize}


\end{document}
